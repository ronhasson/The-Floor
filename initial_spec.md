# Prompt for Codex: Build a local "Arena Floor" game show (Operator + TV Display) with manifest builder and persistent state

You are an expert full-stack engineer. Generate a minimal, production-clean implementation for a local game show called **"Arena Floor"**, inspired by chess-clock duels. The project must run locally with **no servers** beyond a static file server.

### 0) Overall goals

* Create a **Python manifest builder** that scans a folder of categories and images and produces a `manifest.json`.
* Create a **vanilla JS web app** with two pages:

  * `/operator.html` — the control panel used by a human operator.
  * `/display.html` — the TV/second-screen display for the audience.
* The **Operator** is the *single source of truth* for the game state. The **Display** is read-only and updates via `BroadcastChannel`.
* Implement a **chess-clock duel** (only one side’s clock runs at a time; correct answer switches/halts clocks).
* Persist the entire game state in **localStorage**, with **resume**, **edit JSON**, **import/export**, **backup before reset/import**, and a **hard reset** flow.

---

### 1) Directory layout (create exactly this)

```
project/
  GameFolder/
    Transportation/
      1 - Bike.png
      2 - Bus.png
      3 - Car.png
    Shoe Brands/
      1 - nike.png
      2 - adidas.png
      3 - blundstone.png
  tools/
    build_manifest.py
  web/
    index.html          # redirects to /operator.html
    operator.html
    display.html
    app.js              # shared types, state channel, manifest loader, helpers
    operator.js         # operator-only logic & UI wiring (incl. chess clock)
    display.js          # display-only rendering
    styles.css
    manifest.json       # generated by build_manifest.py
    assets/             # (optional) static icons/logos if needed
```

---

### 2) Python manifest builder

**File:** `tools/build_manifest.py`

**Behavior:**

* Scans `project/GameFolder/*`. Each top-level subfolder is a **category**.
* Each file in a category is a **question item** (an image). Supported extensions: `.png .jpg .jpeg .gif .webp`.
* Filenames follow the pattern: `"<index> - <answer>.<ext>"` (e.g., `1 - Bike.png`).

  * Parse `<index>` as integer and `<answer>` as the answer string.
  * If a file doesn’t conform, fallback to alpha order + auto index 1..N, and use the base filename (without extension) as answer.
* Produce `/web/manifest.json` with this **exact shape**:

```json
{
  "version": 1,
  "generatedAt": "ISO8601 UTC",
  "categories": [
    {
      "id": "slug-of-category",
      "name": "Original Category Name",
      "items": [
        {
          "id": "category-slug-<index>",
          "index": <int>,
          "answer": "Answer As In Filename",
          "src": "/GameFolder/<Category>/<index - answer>.<ext>"
        }
      ]
    }
  ]
}
```

* `id` for categories is a **slug** of the folder name (lowercase, non-alnum removed, spaces/dashes collapsed to `-`).
* `src` must be a **web-servable** POSIX path starting with `/`.
* Print a success message with the output path.
* Add defensive handling (skip non-files; ignore unsupported extensions).
* Keep the script small and readable with comments.

**Run instructions (write these as comments at top of script):**

1. Put images under `project/GameFolder/<CategoryName>/`.
2. From `project/`, run: `python tools/build_manifest.py`.
3. Serve `project/` statically (e.g., `python -m http.server`) and open `/web/operator.html`.

---

### 3) Frontend — General

* **No frameworks**. Vanilla JS modules only. No bundlers/build steps.
* **One BroadcastChannel** named **`'arena-game'`** for state updates from Operator → Display.
* **All paths relative** to the repo root so the app works with `python -m http.server` from `project/`.
* **No external network calls** other than loading `web/manifest.json` and local images.
* **Dark theme**, large typography, TV-friendly.

---

### 4) Data models (use exactly these shapes)

**Settings**

```ts
type Settings = {
  defaultTotalMs: number; // e.g., 45000
  locale?: string;
};
```

**Player**

```ts
type Player = {
  id: string;
  name: string;
  cells: number;
  eliminated: boolean;
};
```

**ChessClock**

```ts
type ChessClock = {
  totalMs: number;
  leftRemainingMs: number;
  rightRemainingMs: number;
  runningSide: "left" | "right" | null;
  lastSwitchTs: number | null; // Date.now() when the active side started
  paused: boolean;
};
```

**CurrentItem**

```ts
type CurrentItem = {
  categoryId: string;
  itemIndex: number;  // 1-based
  src: string;        // image path
  answer: string;     // hidden on display until reveal
  revealed: boolean;
};
```

**Scene**

```ts
type Scene = "lobby" | "category_select" | "duel_ready" | "duel_live" | "result" | "pause";
```

**GameState**

```ts
type GameState = {
  version: 1;
  showId: string;       // uuid-v4
  lastSavedAt: number;  // Date.now()
  scene: Scene;
  players: Player[];
  leftPlayerId?: string;
  rightPlayerId?: string;
  clock: ChessClock;
  current?: CurrentItem;
  message?: string;
};
```

---

### 5) Persistence (localStorage) — **must implement**

* Keys:

  * `arena.v1.state` — the entire `GameState` JSON (stringified).
  * `arena.v1.settings` — operator preferences (`Settings`).
  * `arena.v1.backup.<timestamp>` — JSON backup taken automatically **before** Reset or Import.
* On every **state mutation** in the Operator:

  * Update `state.lastSavedAt = Date.now()`.
  * Save to `localStorage["arena.v1.state"]`.
  * Post the **full state snapshot** over `BroadcastChannel` (Display will re-render).
* On **operator startup**:

  1. Load `localStorage["arena.v1.state"]` if present.
  2. If present, show a modal: **“Resume previous show?”** with `[Resume]` / `[Start New Show]`.
  3. Load `localStorage["arena.v1.settings"]` (fallback `defaultTotalMs = 45000`).
  4. If starting new → initialize a **fresh** `GameState` (new `showId`, `scene="lobby"`, empty players, zeroed clock).
* Implement `migrateState(loaded)` for forward-compat (no-op now).
* **Display page never writes** to localStorage.

**State editing & safety flows (Operator):**

* **State Editor**: “Edit JSON” button opens a modal with a `<textarea>` containing pretty-printed state JSON.

  * Buttons: **Validate & Apply** / **Cancel**.
  * On Apply: Validate shape (required fields & types). If invalid → show precise error. If valid → save and broadcast.
* **Export State**: Download pretty JSON file.
* **Import State**: Upload or paste; validate shape first. If valid:

  * **Before replacing**, create a backup snapshot under `arena.v1.backup.<timestamp>`.
  * Replace state, save, broadcast; show success toast.
* **Reset (Start New Show)**:

  * Requires confirm dialog that makes the user type **`RESET`**.
  * Before wiping, create a backup under `arena.v1.backup.<timestamp>`.
  * Clear `arena.v1.state`, initialize a fresh `GameState`, save, broadcast; show success toast.

---

### 6) Operator UI ( `/web/operator.html` + `operator.js` )

Implement a clean control panel with three main areas:

**A) Players**

* Table/list with CRUD:

  * Add player (auto-id UUIDv4), edit name, toggle eliminated, reset cells.
  * Remove player (confirm).
* Always persists changes & broadcasts.

**B) Duel Setup & Controls**

* **Select Duelists**: dropdowns for **Left** / **Right** (from active, non-eliminated players).
* **Select Item**:

  * Category dropdown (from `manifest.json`).
  * Item dropdown (indexes 1..N). On selection, fill `current{categoryId,itemIndex,src,answer,revealed:false}`.
* **Clock Settings**:

  * Input for total time (ms), default from `Settings.defaultTotalMs`. Button “Apply”.
* **Big Controls** (primary buttons, large and keyboard-friendly):

  * **Open Display Window** (uses `window.open('/web/display.html', ...)`).
  * **Start Duel** → initializes clock: `leftRemainingMs = rightRemainingMs = totalMs`, `runningSide="left"`, `lastSwitchTs = Date.now()`, `paused=false`, scene → `duel_live`.
  * **Pause / Resume** (toggles `paused`).
  * **Correct (Left)** / **Correct (Right)** → triggers **SWITCH_TURN** (stop current side, start the other; used when opponent gives a correct answer).
  * **Reveal Answer** (sets `current.revealed = true`).
  * **Timeout (Force)** — triggers timeout on the currently running side.
  * **Declare Winner (Left/Right)** — sets scene `result`, optionally transfer territory by eliminating the loser (checkbox option).
  * **Next Item** — moves back to `category_select` or `duel_ready` (your choice), keeps duelists or resets them per UX note in code.
  * **Reset Duel** — re-init duel clocks without changing players/item.

**Chess Clock loop (Operator only):**

* Use `setInterval(50)` to tick while `paused === false` and `runningSide !== null`.
* Compute elapsed with `Date.now() - lastSwitchTs`, decrement `left/rightRemainingMs` for the active side only.
* When `<= 0`, emit timeout → set scene to `result`, determine winner = other side.
* `SWITCH_TURN`:

  * Finalize remaining for current active side using elapsed.
  * Flip `runningSide`, set `lastSwitchTs = Date.now()`.

**C) State & Storage**

* Show “**Last saved:** <relative time>”.
* Buttons:

  * **Edit JSON**
  * **Export State**
  * **Import State**
  * **Start New Show (Reset)** (danger style, requires typing `RESET`)
* **Settings** form:

  * `defaultTotalMs` (ms) + “Save Settings” → write to `arena.v1.settings` and show toast.
* All actions must call `saveState()` and broadcast.

---

### 7) Display UI ( `/web/display.html` + `display.js` )

* Subscribe to `BroadcastChannel('arena-game')`. **Never mutate** state.
* Render by `state.scene`:

  * **lobby** — logo/title + (optionally) list of players.
  * **category_select** — “Stand by”.
  * **duel_ready** — show the two players’ names large, category title.
  * **duel_live** — **big chess-clock** view: two large name panels with remaining times; central **image** (`current.src`) scaled to fit; answer hidden unless `current.revealed === true` or scene changed; a subtle running indicator on the active side.
  * **result** — winner banner, (optional) territory update indicator.
  * **pause** — overlay “Paused”.
* Responsive, TV-friendly; avoid clutter. No controls.

---

### 8) Actions & events (semantics)

Implement Operator actions as functions that **mutate state**, **save**, and **broadcast**:

* `LOAD_MANIFEST`
* `SET_PLAYERS` / `ADD_PLAYER` / `UPDATE_PLAYER` / `REMOVE_PLAYER`
* `ASSIGN_DUELISTS(leftId,rightId)`
* `SELECT_ITEM(categoryId,itemIndex)`
* `START_DUEL(totalMs?)`
* `SWITCH_TURN()`
* `REVEAL_ANSWER()`
* `TIMEOUT()` (for active side)
* `DECLARE_WINNER(side: "left"|"right", { eliminateLoser?: boolean })`
* `PAUSE()` / `RESUME()`
* `RESET_DUEL()` / `NEXT_ITEM()`
* `UPDATE_SETTINGS(partial)`
* `OPEN_STATE_EDITOR` / `APPLY_STATE_EDITOR(json)` / `CANCEL_STATE_EDITOR`
* `EXPORT_STATE()` / `IMPORT_STATE(json)`
* `RESET_SHOW()` (with confirm “RESET”)

Each must end with `saveState(state)` → updates `lastSavedAt`, writes to localStorage, posts via `BroadcastChannel`.

---

### 9) Styling

* `web/styles.css`: dark theme, large type, high contrast.
* Clearly styled **primary** buttons for Start/Pause/Switch/Declare.
* Danger styling for Reset.
* Modal styles for the State Editor and Resume dialog.

---

### 10) Quality bar & constraints

* Pure ES modules (`type="module"`). No external deps.
* Defensive JSON validation for **Import** and **Edit JSON**:

  * Verify required fields exist and are correct types; give precise error messages.
* Don’t store images in state; respect localStorage limits (~5MB).
* Robust against missing images or malformed filenames (show a fallback).
* Keep files small, commented, and readable.
* Works entirely with `python -m http.server` from the repo root.

---

### 11) Include usage notes (as comments in code)

* **Build manifest:** `python tools/build_manifest.py`
* **Serve:** from `project/` → `python -m http.server` → open `http://localhost:8000/web/operator.html`
* In Operator: press “Open Display Window” to launch `/web/display.html` for TV.
* On first load, if a saved state exists: prompt to **Resume** or **Start New Show**.

---

### 12) Deliverables

Produce **all files with complete code content** (no placeholders):

* `tools/build_manifest.py`
* `web/index.html`
* `web/operator.html`
* `web/display.html`
* `web/app.js`
* `web/operator.js`
* `web/display.js`
* `web/styles.css`

Each file must be self-contained and ready to run as specified above.
